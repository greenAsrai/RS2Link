% !TEX root = ./main_RS2L_LNCS.tex


\section{Background on the CNA}



\section{The Core Network Algebra}
\label{sec:network}

In this section we recall the theory of links and link chains to present the syntax and operational semantics of \CNA.
%In this section we just focus on the basic ideas of link interaction, while we shall enhance the model with name mobility in the next section.


\subsection{Syntax}

\begin{definition}
The \CNA\ processes are generated by the following grammar:
\[
\begin{array}{rcl}
P,Q & ::= &
\nil \prodsep
%X \prodsep
\ell. P  \prodsep
P+Q \prodsep
P|Q \prodsep
\restrict{a} P \prodsep
P[\phi] \prodsep
A
\end{array}
\]
\noindent
where $\ell$ is a solid link (i.e.\  $\ell = \link{\alpha}{\beta}$ with $\alpha,\beta\neq \ \noacts$),
$\phi$ is a channel renaming function,
and $A$ is a process identifier for which we assume a definition $A \defeq P$ is available in a given set $\Delta$ of (possibly recursive) process definitions.
\end{definition}

As usual, we write $\tilde{a}$ for tuples of channels and we allow parametric process definitions of the form $A(\tilde{a}) \defeq P$,
where $\tilde{a}$ is the set of free channels of $P$.
For brevity, in the examples, we sometimes write $A \defeq P$ leaving implicit that the free channles of $P$ are the parameters of $A$.
%that
%stand for the set of definitions $\{ A(\tilde{a}) \defeq P[\tilde{a} \slash \tilde{x}]  \;\mid\; \tilde{a}\; \text{ is a tuple of channels} \}$,
%where $\tilde{x}$ is the set of free channels of $P$.

%\begin{remark}
%The extension in which generic link chains are allowed as action prefixes instead of solid links is discussed in Section~\ref{subsec:altdef}.
%\end{remark}

It is evident that processes are built over a CCS-like syntax,
%\footnote{For brevity, we omit the CCS-like renaming operator $P[\Phi]$ because it will be later subsumed by the syntax in Section~\ref{sec:names}).}
with inactive process $\nil$, action prefix $\ell.P$, choice $P+Q$, parallel $P|Q$, restriction $\restrict{a} P$, renaming $P[\phi]$ and constant definition
 $A$, but where the underlying synchronisation algebra~\cite{DBLP:journals/tcs/Winskel84} is based on link chains.
This is made evident by the operational semantics that we present next.

As usual, $\restrict{a}P$ binds the occurrences of $a$ in $P$, the sets of free and of bound names of a process $P$ are defined in the obvious way and 
processes are taken up to alpha-conversion of bound names.
We shall sometimes omit trailing $\nil$, e.g.~by writing $\link{a}{b}$ instead of $\link{a}{b}.\nil$.


\begin{example}
\CNA\ provides us with a natural way to rephrase the communication primitives of usual process calculi, such as CCS and CSP~\cite{Hoare85}, in terms of links.
\begin{itemize}
\item
Intuitively, the output action $\overline{a}$ (resp. the input action $a$) of CCS can be seen as the link $\link{\silent}{a}$
(resp. $\link{a}{\silent}$) and the solid link chain $\startchain{\silent}\chainedlink{a}{a}\chainend{\silent}$  as a dyadic communication, analogous to the silent action $\tau$ of CCS.
% between an output on $a$ (the link $\link{\silent}{a}$) and an input on $a$ (the link $\link{a}{\silent}$).
\item
The action $a$ of CSP can be seen as the link $\link{a}{a}$ and the solid link chain $\startchain{a}\chainedlink{a}{a}\chainedlink{a}{a}\chainend{a}$ as a CSP-like communication among three peers over $a$.
\end{itemize}
\end{example}



%In particular, to implement I/O communication, each link in the whole chain simply carries the same list or tuple of arguments, 
%but with different (send/receive) capabilities. 
%In this way, we keep apart the interaction mechanism from the name-passing one that eventually fit together in synchronisations.
%We have just borrowed from $\pi$-calculus
%the name handling machinery
%(and liberated it from dyadic interaction legacy), still having input, output and extrusion mechanisms.

%In the tuple $t =\tuple{\vec{w}}$, names can be used either as values or as variables. They are distinguished because variables are underlined.
%During communication, variables are instantiated by values, while
%values are used for matching arguments, as in \cite{BodeiBDG10}.
%\begin{example}\label{ex-tuple}
%Consider e.g., the tuples in the two ``complementary'' prefixes $\link{\tau}{a}\tuple{id,n,\variable{x}}.P$ and $\link{a}{\tau}\tuple{id,\variable{y},m}.Q$: the two links can be merged, the first parameters of the tuples must match exactly,
%$n$ is assigned to $y$, while $m$ is assigned to $x$, where
%$\variable{x}$ is an input for $P$, $\variable{y}$ is an input for $Q$, and $id$ is a name known by both processes.
%\end{example}
%This mechanism allows, e.g., a form of multi-way communication, where all peers involved in the chain link can express arguments to be matched and provide actual arguments to replace the formal ones. 

%
%For a tuple $t$, we let $\values{t}$ and $\variables{t}$ denote the set of values and the set of variables of $t$, respectively. 
%We say that a tuple $t$ is \emph{ground} if $\variables{t} = \emptyset$.

%We assume action names are admissible values, i.e.~ as in $\pi$-calculus we have the possibility to communicate (names of) means of communication.
%Similarly to $\restrict{a}$, the prefix $\ell t.P$ binds the occurrences of the variables $\variables{t}$ in $P$ (and the notions of free names $\fn{P}$, bound names $\bn{P}$ and alpha-conversion are updated accordingly).
%In the following, given two set of names $S$ and $T$, we write $S \# T$ as a shorthand for $S\cap T = \emptyset$.

%
%As usual, $\restrict{a}P$ binds the occurrences of $a$ in $P$, the sets of free names and of bound names of a process $P$ are defined in the obvious way and denoted, respectively, by $\fn{P}$ and $\bn{P}$, processes are taken up to alpha-conversion of bound names, and we shall often omit trailing $\nil$, e.g. by writing $\link{a}{b}$ instead of $\link{a}{b}.\nil$ 



% The only original operator is $\solid{P}$ that filters out incomplete communications
% (i.e.~it allows $P$ to evolve only via solid link chains). 

\subsection{Operational Semantics}

The idea is that communication can be routed across several processes by combining the links they make available to form a link chain. Since the length of the link chain is not fixed {\em a priori}, an open multi-party synchronisation is realised.

% We take as observations only link chains whose extremities are silent,
% i.e.~ are in the form $\tau$, because they have not to be composed further. 

%For compositionality reasons, we allow observations to contain
%virtual links $\link{\noact}{\noact}$, to be provided by the context. 

\begin{figure}[t]
\begin{center} 
\begin{prooftree} 
\AxiomC{$s \blackstretcheq \ell $} %\mbox{($\ell$ {\em only} solid link in $s$)}
\RightLabel{\scriptsize(\textit{Act})}
\UnaryInfC{$\ell.P \xrightarrow{v} P$} 
\DisplayProof
\
\AxiomC{$P \xrightarrow{s} P'$} 
\RightLabel{\scriptsize(\textit{Lsum})}
\UnaryInfC{$P+Q \xrightarrow{v} P'$} 
\DisplayProof
\
\AxiomC{$P \xrightarrow{s} P'$} 
\RightLabel{\scriptsize(\textit{Res})}
\UnaryInfC{$\restrict{a}P \xrightarrow{\restrict{a}s} \restrict{a}P'$} 
%\DisplayProof
%\,
%\AxiomC{$Q \xrightarrow{s} Q'$} 
%\RightLabel{\scriptsize(Rsum)}
%\UnaryInfC{$P+Q \xrightarrow{s} Q'$} 
\end{prooftree} 
\end{center}

\begin{center} 
\begin{prooftree} 
\AxiomC{$P \xrightarrow{s} P'$} 
\RightLabel{\scriptsize(\textit{Ren})}
\UnaryInfC{$P[\phi] \xrightarrow{s[\phi]} P'[\phi]$} 
\DisplayProof
\
\AxiomC{$P \xrightarrow{s} P'$} 
\RightLabel{\scriptsize(\textit{Lpar})}
\UnaryInfC{$P|Q \xrightarrow{s} P'|Q$} 
\DisplayProof
\ 
%\AxiomC{$Q \xrightarrow{s} Q'$} 
%\RightLabel{\scriptsize(Rpar)}
%\UnaryInfC{$P|Q \xrightarrow{s} P|Q'$} 
%\end{prooftree} 
%\end{center}
%\begin{center} 
%\begin{prooftree} 
\AxiomC{$P \xrightarrow{s} P'$} 
\AxiomC{$Q \xrightarrow{s'} Q'$} 
\RightLabel{\scriptsize(\textit{Com})}
\BinaryInfC{$P|Q \xrightarrow{\merges{s}{s'}} P'|Q'$} 
\DisplayProof
\end{center}
\begin{center}
%\AxiomC{$P[\subst{\recproc{X}{P}}{X}] \xrightarrow{s} P'$} 
%\RightLabel{\scriptsize(Rec)}
%\UnaryInfC{$\recproc{X}{P} \xrightarrow{s} P'$} 
\AxiomC{$P \xrightarrow{s} P'$}
 \AxiomC{$(A \defeq P)\in\Delta$}
\RightLabel{\scriptsize(\textit{Ide})}
\BinaryInfC{$A \xrightarrow{s} P'$} 
\end{prooftree} 
\end{center}
\caption{SOS semantics of the \CNA\  (rules (\textit{Rsum}) and (\textit{Rpar}) are omitted).}
\label{fig:cnasos}
\end{figure}

The operational semantics is defined in terms of a Labelled Transition System, in which states are \CNA\ processes, labels are link chains, and transitions are generated by the SOS rules in Figure~\ref{fig:cnasos}. 
% 
%%The standard rules \textit{(Rsum)} and \textit{(Rpar)}, symmetric of \textit{(Lsum)} and \textit{(Lpar)} are omitted for brevity.
Notice that the rules are very similar to the ones of CCS, 
apart from the labels that record the link chains involved in the transitions:
moving from dyadic to \emph{linked} interaction does not introduce any complexity burden from the formal point of view.

We comment in details the rules (\textit{Act}), (\textit{Res}), and (\textit{Com}). 
In rules (\textit{Res}) and (\textit{Com}) we leave implicit the side conditions $\restrict{a}s \neq \bot$ and $\merges{s}{s'} \neq \bot$, respectively (they can be easily recovered by noting that otherwise the label of the transition in the conclusion would be undefined).

The rule (\textit{Act}) states that $\ell.P \xrightarrow{s} P$ for any link chain $s$, whose unique solid link is $\ell$,  i.e.\  any $s$ such that $s \blackstretcheq \ell$
(we recall that $s \blackstretcheq \ell$ if $s$ and $\ell$  differ only for the presence of virtual links).
Intuitively, $\ell.P$ can take part in any interaction, in any (admissible) position.
To join in a communication, $\ell.P$ should exhibit the capability to enlarge its link $\ell$ to a link chain $s \blackstretcheq \ell$, whose length is the same as the length of the chains offered by all the other participants, so to proceed with the merge operation. Following the early style, the suitable length is 
%guessed
inferred at the time of deducing the input transition.
Note that, by definition of link chain, if one site of $\ell$ is $\silent$, then $\ell$ can only appear at one of the extremes of $s$.

The rule (\textit{Res}) can serve different aims: 
(i) \emph{floating}, if $a$ does not occur in $s$, then $\restrict{a}s = s$ and  $\restrict{a}P \xrightarrow{s} \restrict{a}P'$;
(ii) \emph{hiding}, if $a$ is matched in $s$ ( i.e.\  $a$ appears as sites already matched by adjacent links), then all occurrences of $a$ in $s$ are transformed to $\silent$ in $\restrict{a}s$;
(iii) \emph{blocking}, if $a$ is pending in $s$ ( i.e.\  there are some
unmatched occurrences of $a$ in $s$), then $\restrict{a}s = \bot$ and the rule cannot be applied.

In the (\textit{Com}) rule the link chains recorded on both the premises' transitions are merged in the conclusion's transition.
This is possible only if $s$ and $s'$ are to some extent ``complementary''.
Contrary to CCS, the rule (\textit{Com}) can appear several times in the proof tree of a transition, because $\merges{s}{s'}$ can still contain virtual links (if $s$ and $s'$ had a virtual link in the same position) and can possibly be merged with other link chains.
However, when $\merges{s}{s'}$ is solid, no further synchronisation is possible (by Lemma~\ref{lemma:solid} (ii)).

%
%A \xrightarrow{a} B. 
%
%
\begin{example}
Let
% $R = \solid{P}$, 
$P = \link{\silent}{a}.P_{1}\ |\ \restrict{b} Q$ and $Q = \link{b}{\silent}.P_{2}\ |\ \link{a}{b}.\nil$, for some processes $P_1$ and $P_2$.
The process $\link{\silent}{a}.P_{1}$ can perform an output on $a$, the process $ \link{b}{\silent}.P_{2}$ can perform an input from $b$; the process $\link{a}{b}$ provides a one-shot link forwarder from $a$ to $b$. 
Their links match along the sequence and a three-party interaction can take place.
Together, these processes can indeed synchronise by agreeing to form the solid link chain
${\startchain{\silent}\chainedlink{a}{a}\chainedlink{\silent}{\silent}\chainend{\silent}}$ of length three, as follows.\footnote{Note that $b$ is restricted and therefore the matched communication on $b$ is replaced by $\tau$ in the observed chain.}


{\small
\begin{center} 
\begin{prooftree} 
\AxiomC{} 
\RightLabel{\scriptsize(\textit{Act})}
\UnaryInfC{$\link{\silent}{a}.P_{1} \xrightarrow{\startchain{\silent}\chainedlink{a}{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}} P_{1}$} 
%
\! \!\!\! \!\!
%\begin{prooftree} 
      \AxiomC{} 
      \RightLabel{\scriptsize(\textit{Act})}
      \UnaryInfC{$\link{b}{\silent}.P_{2} \xrightarrow{\startchain{\noact}\chainedlink{\noact}{\noact}\chainedlink{\noact}{b}\chainend{\silent}} P_{2}$} 
      %
      \AxiomC{} 
      \RightLabel{\scriptsize(\textit{Act})}
      \UnaryInfC{$\link{a}{b}.\nil \xrightarrow{\startchain{\noact}\chainedlink{\noact}{a}\chainedlink{b}{\noact}\chainend{\noact}} \nil$} 
   \RightLabel{\scriptsize(\textit{Com})}
\BinaryInfC{$Q \xrightarrow{\startchain{\noact}\chainedlink{\noact}{a}\chainedlink{b}{b}\chainend{\silent}} P_{2}|\nil$} 
%\end{prooftree} 
%
%\AxiomC{$Q \xrightarrow{\startchain{\noact}\chainedlink{\noact}{a}\chainedlink{b}{b}\chainend{\silent}} P_{2}|\nil$} 
   \RightLabel{\scriptsize(\textit{Res})}
   \UnaryInfC{$\restrict{b}Q \xrightarrow{\startchain{\noact}\chainedlink{\noact}{a}\chainedlink{\silent}{\silent}\chainend{\silent}} \restrict{b} (P_{2}|\nil)$} 
\RightLabel{\scriptsize(\textit{Com})}
\BinaryInfC{$P \xrightarrow{\startchain{\silent}\chainedlink{a}{a}\chainedlink{\silent}{\silent}\chainend{\silent}} P_{1}|\restrict{b} (P_{2}|\nil)$} 
\end{prooftree} 
\end{center}
}

%where
%%
%{\scriptsize
%\begin{center} 
%\begin{prooftree} 
%      \AxiomC{} 
%      \RightLabel{\scriptsize(Act)}
%      \UnaryInfC{$\link{b}{\silent}.P_{2} \xrightarrow{\startchain{\noact}\chainedlink{\noact}{\noact}\chainedlink{\noact}{b}\chainend{\silent}} P_{2}$} 
%      %
%      \AxiomC{} 
%      \RightLabel{\scriptsize(Act)}
%      \UnaryInfC{$\link{a}{b}.\nil \xrightarrow{\startchain{\noact}\chainedlink{\noact}{a}\chainedlink{b}{\noact}\chainend{\noact}} \nil$} 
%   \RightLabel{\scriptsize(Com)}
%\BinaryInfC{$Q \xrightarrow{\startchain{\noact}\chainedlink{\noact}{a}\chainedlink{b}{b}\chainend{\silent}} P_{2}|\nil$} 
%\end{prooftree} 
%\end{center}
%}

%\noindent
%and the suitable chain length, $3$, is inferred and agreed on by all participants.
\end{example}

The following lemma, whose proof goes by rule induction, shows that labels behave like an accordion.
Concretely, any label $s$ in a transition is replaceable with any other chain having a different number of virtual links $\link{\noact}{\noact}$ added to $s$ according to the axioms of $\blackstretcheq$. 
% It is also replaceable with any composition where each $\link{\noact}{\noact}$ inside $s$ is replaced by one or more $\link{\noact}{\noact}$.
The result builds on the previous technical Lemmata~\ref{lem:mergestretch} and~\ref{lemma:res}.
This fact will be later exploited in Section~\ref{abs-sem}, where the abstract semantics is given.



\begin{lemma}[Accordion Lemma]\label{lem:stretchlts}
If $P\xrightarrow{s} P'$ and $s \blackstretcheq s'$,
then $P\xrightarrow{s'} P'$.
\end{lemma}




%\item[(i)]
%If $P\xrightarrow{s} P'$ and $s\link{\noact}{\noact}$ (respectively $\link{\noact}{\noact}s$) is valid,
%then $P\xrightarrow{s\link{\noact}{\noact}} P'$  (respectively $P\xrightarrow{\link{\noact}{\noact}s} P'$).
%\\
%Vice versa, if $P\xrightarrow{s'} P'$ and $s'=s\link{\noact}{\noact}$ or $s'=\link{\noact}{\noact}s$, 
%then $P\xrightarrow{s} P'$.
%
%\item[(ii)]
%If $P\xrightarrow{s_{1}\link{\noact}{\noact}s_{2}} P'$  
%then $P\xrightarrow{s_{1}\startchain{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}s_{2}} P'$.
%\\
%Vice versa, if $P\xrightarrow{s_{1}\startchain{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}s_{2}} P'$ 
%then $P\xrightarrow{s_{1}\link{\noact}{\noact}s_{2}} P'$.
%
%\item[(iii)]
%If $P\xrightarrow{s_{1}\startchain{\alpha}\chainedlink{a}{a}\chainend{\beta}s_{2}} P'$ 
%then $P\xrightarrow{s_{1}\startchain{\alpha}\chainedlink{a}{\noact}\chainedlink{\noact}{a}\chainend{\beta}s_{2}} P'$.
%\\
%Vice versa, if $P\xrightarrow{s_{1}\startchain{\alpha}\chainedlink{a}{\noact}\chainedlink{\noact}{a}\chainend{\beta}s_{2}} P'$
%then $P\xrightarrow{s=s_{1}\startchain{\alpha}\chainedlink{a}{a}\chainend{\beta}s_{2}} P'$.


%\begin{lemma}
%If $P\xrightarrow{s} P'$, 
%then $P\xrightarrow{s\link{\noact}{\noact}} P'$ and $P\xrightarrow{\link{\noact}{\noact}s} P'$.

%\noindent
%Vice versa, if $P\xrightarrow{s'} P'$ and $s'=s\link{\noact}{\noact}$ or $s'=\link{\noact}{\noact}s$, 
%then $P\xrightarrow{s} P'$.

%\end{lemma}

%\begin{lemma}
%If $P\xrightarrow{s_{1}\link{\noact}{\noact}s_{2}} P'$  
%then $P\xrightarrow{s_{1}\startchain{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}s_{2}} P'$ .
%%
%Vice versa, if $P\xrightarrow{s_{1}\startchain{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}s_{2}} P'$ 
%then $P\xrightarrow{s_{1}\link{\noact}{\noact}s_{2}} P'$.
%\end{lemma}

%
%\begin{lemma}
%If $P\xrightarrow{s_{1}\startchain{\alpha}\chainedlink{a}{a}\chainend{\beta}s_{2}} P'$ 
%then $P\xrightarrow{s_{1}\startchain{\alpha}\chainedlink{a}{\noact}\chainedlink{\noact}{a}\chainend{\beta}s_{2}} P'$.
%%
%Vice versa, if $P\xrightarrow{s_{1}\startchain{\alpha}\chainedlink{a}{\noact}\chainedlink{\noact}{a}\chainend{\beta}s_{2}} P'$
%then $P\xrightarrow{s=s_{1}\startchain{\alpha}\chainedlink{a}{a}\chainend{\beta}s_{2}} P'$.

%\end{lemma}

%\textcolor{blue}{METTIAMO QUI O ALTROVE LE SEGUENTI PRECISAZIONI MESSE IN SciAnnals?
%To better focus on the way in which the merge of link chains is performed, we present a simple
%example.
%We recall that the definition of the $\merges{}{}$ operator requires that the two involved link chains must be of the same length, and that, by rule \textit{(Act)}
%we can arbitrarily add virtual links, in any position.
%%, to get the point. \\
%%
%Let 
%$s_1 = \link{\silent}{b}$, $s_2 = \link{b}{c}$, and  $s_3 = \link{c}{\tau}$ be three links, then there are three possible combinations for applying the $\merges{}{}$ operator:
%\begin{itemize}
%\item  we can first define
% $s_1' = \startchain{\silent}\chainedlink{b}{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}$, 
% $s_2' = \startchain{\noact}\chainedlink{\noact}{b}\chainedlink{c}{\noact}\chainend{\noact}$, and compute 
% $s_4 = \merges{s_1'}{s_2'}=\startchain{\tau}\chainedlink{b}{b}\chainedlink{c}{\noact}\chainend{\noact}$;
% then we can define 
% $s_3' =  \startchain{\silent}\chainedlink{b}{b}\chainedlink{c}{c}  \chainend{\silent}$, and, finally, we can compute 
% $s = \merges{s_4}{s_3'} =\startchain{\silent}\chainedlink{b}{\noact}\chainedlink{\noact}{c}
%\chainend{\silent}$; or
%%
%\item we can first define $s_1' = \startchain{\silent}\chainedlink{b}{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}$, 
%$s_3' = \startchain{\noact}\chainedlink{\noact}{\noact}\chainedlink{\noact}{c}\chainend{\silent}$, and compute 
%$s_4 = \merges{s_1'}{s_3'} =  \startchain{\silent}\chainedlink{b}{\noact}\chainedlink{\noact}{c}\chainend{\silent}$; then we can define 
%$s_2' = \startchain{\noact}\chainedlink{\noact}{b}\chainedlink{c}{\noact}\chainend{\noact}$, 
%and finally we can compute 
%$s=\merges{s_2'}{s_4}= \startchain{\silent}\chainedlink{b}{b}\chainedlink{c}{c}
%\chainend{\silent}$; or
%%
%\item we can first define 
%$s_3' = \startchain{\noact}\chainedlink{\noact}{\noact}\chainedlink{\noact}{c}\chainend{\silent}$, 
%$s_2' = \startchain{\noact}\chainedlink{\noact}{b}\chainedlink{c}{\noact}\chainend{\noact}$, 
%and compute 
%$s_4 = \merges{s_2'}{s_3'}= \startchain{\noact}\chainedlink{\noact}{b}\chainedlink{c}{c}\chainend{\silent}$; 
%then we can define 
%$s_1' = \startchain{\silent}\chainedlink{b}{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}$; 
%and finally we can compute 
%$s=\merges{s_1'}{s_4}= \startchain{\silent}\chainedlink{b}{b}\chainedlink{c}{c}\chainend{\silent}$.
%% $s_1' =  \link{\silent}{b}\link{*}{*}\link{*}{*}$, $s_2' = \link{*}{*}\link{b}{c}\link{*}{*}$, and compute $s_4 = \merges{s_1'}{s_2'}=\link{\silent}{b}\link{b}{c}\link{*}{*} $; then we can define $s_3' =  \link{*}{*}\link{*}{*} \link{c}{\silent}$, and, finally, we can compute $s = \merges{s_4}{s_3'} =\link{\silent}{b}\link{b}{c} \link{c}{\tau}$; or
%%\item we can first define $s_1' = \link{\silent}{b}\link{*}{*} \link{*}{*}$, $s_3' =  \link{*}{*}\link{*}{*} \link{c}{\silent}$, and compute $s_4 = \merges{s_1'}{s_3'} =  \link{\silent}{b}\link{*}{*} \link{c}{\silent}$; then we can define $s_2' = \link{*}{*}\link{b}{c}\link{*}{*}$, and finally we can compute $s=\merges{s_2'}{s_4}= \link{\silent}{b}\link{b}{c} \link{c}{\silent} $; or
%%\item we can first define $s_3' = \link{*}{*}\link{*}{*}\link{c}{\silent}$, $s_2' = \link{*}{*}\link{b}{c}\link{*}{*}$, 
%%and compute $s_4 = \merges{s_2'}{s_3'}= \link{*}{*}\link{b}{c}\link{c}{\silent}$; then we can
%%define $s_1' = \link{\silent}{b}\link{*}{*}\link{*}{*}$; and finally we can compute $s=\merges{s_1'}{s_4}= \link{\silent}{b}\link{b}{c}\link{c}{\silent}$.
%\end{itemize}
%}

\begin{example}[Forwarders]
We give a few examples to show how flexible is \CNA\ for defining ``forwarding'' policies.
We have already seen a one-shot and one-hop forwarder from $a$ to $b$ that can be written as $\link{a}{b}.\nil$.
Its persistent version is just written as $R(a,b) \defeq \link{a}{b}.R(a,b)$.
Moreover, the process $R(a,b) \ | R(b,a)$ provides a sort of name fusion, making $a$ and $b$ interchangeable.

% \textcolor{cyan}{(Hereafter, we denote a tuple $a_1,...,a_n$ with $\tilde{a}$).}
An alternating forwarder $A(a,b,c)$ from $a$ to $b$ first and then to $c$ can be defined as 
\[A(a,b,c) \defeq \link{a}{b}.\link{a}{c}.A(a,b,c).\]

A persistent non-deterministic forwarder $C(a,\widetilde{c})$ (the $C$ stands for \emph{choice}), from $a$ to $c_{1},...,c_{n}$ can be \mbox{written as} 
\[C(a,\widetilde{c}) \defeq \link{a}{c_{1}}.C(a,\widetilde{c})+ \cdots + \link{a}{c_{n}}.C(a,\widetilde{c}).\]

Similarly, $J(\widetilde{b},a)$ defined as (the $J$ stands for \emph{join}\footnote{With the term ``join'' we refer to the fact that messages from different sources are forwarded to the same channel. It has no relation with join patterns in join calculus.})
\[J(\widetilde{b},a)\defeq \link{b_{1}}{a}.J(\widetilde{b},a) + \cdots + \link{b_{m}}{a}.J(\widetilde{b},a)\] 
is a persistent non-deterministic forwarder, from $b_{1},...,b_{m}$ to $a$.

By combining the two processes above as in
\[F(\widetilde{b},\widetilde{c}) \defeq \restrict{a}(J(\widetilde{b},a)\ |\ C(a,\widetilde{c}))\]
we obtain a persistent forwarder from any of  the $b_{i}$'s  to any of the $c_{j}$'s.
The only admissible transitions have indeed the form
$
F(\widetilde{b},\widetilde{c})  \xrightarrow{s} F(\widetilde{b},\widetilde{c})
$
with $s \blackstretcheq \startchain{b_i}\chainedlink{\silent}{\silent}\chainend{c_j}$ for some $i\in[1,m]$ and $j\in[1,n]$ (because interaction on $a$ is restricted and $\restrict{a}(\startchain{b_i}\chainedlink{a}{a}\chainend{c_j}) = \startchain{b_i}\chainedlink{\silent}{\silent}\chainend{c_j}$).
%As an advantage, note that the combinatorial explosion is taken care of by the communication rules, and it does not affect the ``size'' of the processes.
%By combining the processes $\restrict{a}(P^{d,e}_{a} | A^{a}_{b,c})$, then we obtain a persistent forwarder from either $d$ or $e$ to $b$ and $c$ in alternation.
\end{example}

\begin{example}[Blind routing in \CNA]
We have already observed that CCS processes can be transformed to \CNA\ processes just by transforming action prefixes in link prefixes. Correspondingly, the blind routing example from Section~\ref{sec:CCS} (Example~\ref{blind}) can be encoded in \CNA\ just as follows, where for readability we have omitted the parameters from definitions.
%
\begin{eqnarray*}
A_i & \defeq & \link{\tau}{\mathit{req}_i}.\link{\tau}{\mathit{think}}.A_i\quad \mbox{ for $i\in[1,2]$} \\
S_j & \defeq & \link{\mathit{srv}_j}{\tau}.\link{\tau}{\mathit{exec}}.S_j + \link{\tau}{\mathit{busy}}.\link{\tau}{\tau}.S_j\quad \mbox{ for $j\in[1,2]$}\\
R & \defeq & \link{\mathit{req}_1}{\tau}.(\link{\tau}{\mathit{srv}_1}.R + \link{\tau}{\mathit{srv}_2}.R) + \link{\mathit{req}_2}{\tau}.\link{\tau}{\mathit{srv}_2}.R \\
N & \defeq &
\restrict{\widetilde{\mathit{req}}} 
\restrict{\widetilde{\mathit{srv}}}
(A_1\ |\ A_2\ |\ R\ |\ S_1\ |\ S_2)
\end{eqnarray*}

For example, the following transitions can be derived from the SOS rules accounting for the case where a request from $A_1$ is assigned to $S_2$:
\begin{eqnarray*}
N
& \xrightarrow{ \startchain{\tau}\chainedlink{\tau}{\tau}\chainend{\tau} } &
\restrict{\widetilde{\mathit{req}}} 
\restrict{\widetilde{\mathit{srv}}}
(\link{\tau}{\mathit{think}}.A_1\ |\ A_2\ |\ (\link{\tau}{\mathit{srv}_1}.R + \link{\tau}{\mathit{srv}_2}.R)\ |\ S_1\ |\ S_2)
\\
& \xrightarrow{ \startchain{\tau}\chainedlink{\tau}{\tau}\chainend{\tau} } &
\restrict{\widetilde{\mathit{req}}} 
\restrict{\widetilde{\mathit{srv}}}
(\link{\tau}{\mathit{think}}.A_1\ |\ A_2\ |\ R\ |\ S_1\ |\ \link{\tau}{\mathit{exec}}.S_2)
\\
& \xrightarrow{ \link{\tau}{\mathit{think}} } &
\restrict{\widetilde{\mathit{req}}} 
\restrict{\widetilde{\mathit{srv}}}
(A_1\ |\ A_2\ |\ R\ |\ S_1\ |\ \link{\tau}{\mathit{exec}}.S_2)
\\
& \xrightarrow{ \link{\tau}{\mathit{exec}} } &
N
\end{eqnarray*}

Note that, in the first two steps, interactions on channels $\mathit{req}_1$ and $\mathit{srv}_2$ are restricted and thus not observable, in fact $\restrict{\mathit{req}_1}(\startchain{\tau}\chainedlink{\mathit{req}_1}{\mathit{req}_1}\chainend{\tau}) = \startchain{\tau}\chainedlink{\tau}{\tau}\chainend{\tau}$ and $\restrict{\mathit{srv}_2}(\startchain{\tau}\chainedlink{\mathit{srv}_2}{\mathit{srv}_2}\chainend{\tau}) = \startchain{\tau}\chainedlink{\tau}{\tau}\chainend{\tau}$.

\end{example}

\begin{example}[Acknowledged routing in \CNA]
The features of \CNA\ become evident in our running example when we come to modelling acknowledged routing  (Example~\ref{ack}). This is because the explicit acknowledgment is no longer necessary as it can be implicitly accounted for by the ability to construct a chain of links.\footnote{Of course, one could also just encode the CCS processes for acknowledged routing just by translating their prefixes as we have done for blind routing.}
Correspondingly, we set
\begin{eqnarray*}
A_i & \defeq & \link{\tau}{\mathit{req}_i}.\link{\tau}{\mathit{think}}.A_i\quad \mbox{ for $i\in[1,2]$} \\
S_j & \defeq & \link{\mathit{srv}_j}{\tau}.\link{\tau}{\mathit{exec}}.S_j + \link{\tau}{\mathit{busy}}.\link{\tau}{\tau}.S_j\quad \mbox{ for $j\in[1,2]$}\\
R & \defeq & \link{\mathit{req}_1}{\mathit{srv}_1}.R + \link{\mathit{req}_1}{\mathit{srv}_2}.R + \link{\mathit{req}_2}{\mathit{srv}_2}.R \\
M & \defeq &
\restrict{\widetilde{\mathit{req}}} 
\restrict{\widetilde{\mathit{srv}}}
(A_1\ |\ A_2\ |\ R\ |\ S_1\ |\ S_2)
\end{eqnarray*}
Note that channels $\mathit{ack}_i$ are not needed and \CNA\ processes $A_i$ and $S_j$ are defined as in the case of blind routing; only the syntax of $R$ has been changed to link, in one single step, the requests from agents with the availability of servers.

For example, the following transitions can be derived from the SOS rules accounting for the case where a request from $A_1$ is assigned to $S_2$:
\begin{eqnarray*}
M
& \xrightarrow{ \startchain{\tau}\chainedlink{\tau}{\tau}\chainedlink{\tau}{\tau}\chainend{\tau} } &
\restrict{\widetilde{\mathit{req}}} 
\restrict{\widetilde{\mathit{srv}}}
(\link{\tau}{\mathit{think}}.A_1\ |\ A_2\ |\ R\ |\ S_1\ |\ \link{\tau}{\mathit{exec}}.S_2)
\\
& \xrightarrow{ \link{\tau}{\mathit{think}} } &
\restrict{\widetilde{\mathit{req}}} 
\restrict{\widetilde{\mathit{srv}}}
(A_1\ |\ A_2\ |\ R\ |\ S_1\ |\ \link{\tau}{\mathit{exec}}.S_2)
\\
& \xrightarrow{ \link{\tau}{\mathit{exec}} } &
M
\end{eqnarray*}

Note that, in the first step, the interaction on channels $\mathit{req}_1$ and $\mathit{srv}_2$ is restricted and thus not observable, in fact $\restrict{\mathit{req}_1}\restrict{\mathit{srv}_2}(\startchain{\tau}\chainedlink{\mathit{req}_1}{\mathit{req}_1}\chainedlink{\mathit{srv}_2}{\mathit{srv}_2}\chainend{\tau}) = \startchain{\tau}\chainedlink{\tau}{\tau}\chainedlink{\tau}{\tau}\chainend{\tau}$.

\end{example}

\begin{example}[Composite, acknowledged routing in \CNA]
Notably, the infrastructure presented in the previous example is already designed in a modular way: infrastructures can be composed without requiring any change and no dead path detection or backtracking mechanisms have to be put in place, because they are taken care by the  \CNA\ ``middleware''.

For instance, take the \CNA\ versions of the infrastructures presented in Example~\ref{composite}:
\begin{eqnarray*}
R' & \defeq & \link{\mathit{req}_1}{s_1}.R' + \link{\mathit{req}_1}{s_2}.R' + \link{\mathit{req}_2}{s_2}.R' \\
R'' & \defeq & \link{s_1}{s'_1}.R'' + \link{s_2}{s'_2}.R' \\
R''' & \defeq & \link{s'_2}{\mathit{srv}_2}.R''' \\
R & \defeq & \restrict{\widetilde{s'}}\restrict{\widetilde{s}} (R'\ |\ R''\ |\ R''')
\end{eqnarray*}

Besides looking considerably more concise than their CCS versions, they make evident that the delivery of any request to a server is atomic as any process executes one (link) action and reduces (recursively) to itself.

At a closer inspection, one may notice that the only possible transitions for $R$ are the following ones 
(up to $\blackstretcheq$, as explained by the Accordion Lemma~\ref{lem:stretchlts}):
\[
R \xrightarrow{\startchain{\mathit{req}_1}\chainedlink{\tau}{\tau}\chainedlink{\tau}{\tau}\chainend{\mathit{srv}_2}} R
\quad\mbox{ and }\quad
R \xrightarrow{\startchain{\mathit{req}_2}\chainedlink{\tau}{\tau}\chainedlink{\tau}{\tau}\chainend{\mathit{srv}_2}} R.
\]

As in the previous examples, note that, e.g.\ in the first step, the interaction on channels $s_2$ and $s'_2$ is restricted and thus not observable, in fact
$\restrict{s_2}\restrict{s'_2} \startchain{\mathit{req}_1}\chainedlink{s_2}{s_2}\chainedlink{s'_2}{s'_2}\chainend{\mathit{srv}_2}= 
\startchain{\mathit{req}_1}\chainedlink{\tau}{\tau}\chainedlink{\tau}{\tau}\chainend{\mathit{srv}_2}$.



Therefore, at a suitable level of abstraction, in which routing details are omitted, we would like to relate the composite infrastructure $R$ with the monolithic infrastructure $R_m$ defined as follows:
\begin{eqnarray*}
R_m & \defeq & \link{\mathit{req}_1}{\mathit{srv}_2}.R_m + \link{\mathit{req}_2}{\mathit{srv}_2}.R_m
\end{eqnarray*}

In the next section we show how this can be formalised.
\end{example}







