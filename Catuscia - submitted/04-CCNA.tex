% !TEX root = ./main_RS2L_LNCS.tex

\section{Chained \CNA \ (c\CNA)}
\label{sec:ccna}

In this section we introduce  the syntax and operational semantics
of a variant of the {\tt link}-calculus~\cite{BodeiBB12}, the c\CNA\  (chained \CNA)
where the prefixes are link chains.
%In this section we just focus on the basic ideas of link
% interaction, while we shall enhance the model with name mobility in
% the next section.

\paragraph{Link Chains.}
Let $\mathcal{C}$ be the set of channels, ranged over by $a,b,...$, and 
let $\mathcal{A} = \mathcal{C} \cup \setof{\silent} \cup \setof{{\noacts}}$ be the set of actions, ranged over by $\alpha,\beta,...$,
where the symbol $\silent$ denotes a \emph{silent} action, while the symbol $\noact$ denotes a \emph{virtual} (non-specified) action.
A \emph{link} is a pair $\ell=\link{\alpha}{\beta}$;
it is \emph{solid} if $\alpha,\beta \neq \ \noacts$; 
the link $\link{\noact}{\noact}$ is called \emph{virtual}.
A link is \emph{valid} if it is solid or virtual.
We let $\mathcal{L}$ be the set of valid links.
%
A \emph{link chain} is a 
finite sequence $v = \ell_{1}...\ell_{n}$ of (valid) links  $\ell_{i} = \link{\alpha_{i}}{\beta_{i}}$ such that:
\begin{enumerate}
\item for any $i\in [1,n-1]$, 
$\left\{\begin{array}{ll}
\beta_{i},\alpha_{i+1}\in \mathcal{C} & \mbox{ implies } \beta_{i} = \alpha_{i+1}\\
\beta_{i}=\silent & \mbox{ iff } \alpha_{i+1}=\silent
\end{array}\right.
$
\item  $\exists i \in [1,n]. \ \ell_i \neq \link{\noact}{\noact}$.
\end{enumerate}

Virtual links represent missing elements of a chain. 
The equivalence $\blackstretcheq$ models expansion/contraction of virtual links to adjust the length of a link chain.


\begin{definition}[Equivalence $\blackstretcheq$]\label{def:black}
We let $\blackstretcheq$ be the least equivalence relation 
over link chains closed under the axioms (whenever both sides are well defined):
\[
\begin{array}{rclcrcl}
v\link{\noact}{\noact} & \blackstretcheq &  v & \qquad &
v_1 \startchain{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}v_2 & \blackstretcheq & v_1 \link{\noact}{\noact} v_2\\
\link{\noact}{\noact}v & \blackstretcheq & v & &
v_1 \startchain{\alpha}\chainedlink{a}{a}\chainend{\beta} v_2
& \blackstretcheq & 
v_1 \startchain{\alpha}\chainedlink{a}{\noact}\chainedlink{\noact}{a}\chainend{\beta}v_2 
\end{array}
\]
\end{definition}

Two link chains of equal length can be merged whenever each position occupied by a solid link in one chain is occupied by a virtual link in the other chain and solid links in adjacent positions match. Positions occupied by virtual links in both chains remain virtual. Merging is denoted by $\merges{v_1}{v_2}$.
%
For example, given $v_1 = \startchain{a}\chainedlink{b}{\noact}\chainedlink{\noact}{\noact}\chainend{\noact}$ and $v_2 = \startchain{\noact}\chainedlink{\noact}{b}\chainedlink{c}{\noact}\chainend{\noact}$ we have $\merges{v_1}{v_2} = \startchain{a}\chainedlink{b}{b}\chainedlink{c}{\noact}\chainend{\noact}$.

Some names in a link chain can be restricted as non observable and transformed into silent actions $\silent$. This is possible only if they are matched by some adjacent link. Restriction is denoted by $\restrict{a}v$.
%
For example, given $v = \startchain{a}\chainedlink{b}{b}\chainedlink{c}{\noact}\chainend{\noact}$ we have 
$\restrict{b}v = \startchain{a}\chainedlink{\silent}{\silent}\chainedlink{c}{\noact}\chainend{\noact}$.

\paragraph{Syntax.}
%\begin{definition}
The c\CNA\ processes are generated by the following grammar:
\[
\begin{array}{rcl}
P,Q & ::= &
%\nil \prodsep
%X \prodsep
%s.P  \prodsep
\sum_{i\in I} \upsilon_i.P_i \prodsep
P|Q \prodsep
\restrict{a} P \prodsep
P[\phi] \prodsep
A
\end{array}
\]
\noindent
where $\upsilon_i$ is a  link chain,
%(i.e.\  $\upsilon_i =
%\startchain{\alpha}\chainedlink{\beta}{\noacts}\chainedlink{\noacts}{\alpha'}\chainend{\beta'}$
%with $\alpha,\alpha',\beta,\beta'\neq \ \noacts$),
$\phi$ is a channel renaming function,
and $A$ is a process identifier for which we assume a definition $A
\defeq P$ is available in a given set $\Delta$ of (possibly
recursive) process definitions. We let $\nil$, the inactive process,
denote the empty summation.
%\end{definition}

The syntax of c\CNA\  extends that of \CNA~\cite{BBB17} by allowing to use link chains as prefixes instead of links.
For the rest it features nondeterministic choice, parallel composition, restriction, relabelling and possibly recursive definitions. Here we do not consider name mobility, which is present instead in the {\tt link}-calculus.
\paragraph{Semantics.}

The operational semantics of c\CNA\ is defined in the SOS style by the inference rules in Fig.\ref{fig:cnasos}. The rules are reminiscent of those for Milner's CCS and they essentially coincide with those of \CNA\ in~\cite{BBB17}. The only difference is due to the presence of prefixes that are link chains.
Briefly: rule (\textit{Sum}) selects one alternative and puts as label a possible contraction/expansion of the link chain in the selected prefix; rule (\textit{Ide}) selects one transition of the defining process for a constant; rule (\textit{Res}) restricts some names in the label (it cannot be applied when $\restrict{a}v$ is not defined); rules (\textit{Lpar}) and (\textit{Rpar}) account for interleaving in parallel composition; rule (\textit{Com}) 
synchronises interactions (it cannot be applied when $\merges{v}{v'}$ is not defined).

Analogously to \CNA, the operational semantics of c\CNA\ satisfies the so called Accordion Lemma: whenever $P \xrightarrow{v} P'$ and $v'\blackstretcheq v$ then $P \xrightarrow{v'} P'$.

%\begin{figure}[t]
%\begin{center} 
%\begin{prooftree} 
%\AxiomC{$\upsilon' \blackstretcheq \upsilon $} %\mbox{($\ell$ {\em only} solid link in $s$)}
%\RightLabel{\scriptsize(\textit{Act})}
%\UnaryInfC{$\upsilon.P \xrightarrow{\upsilon'} P$} 
%% \DisplayProof
%\end{prooftree}
%\end{center}
%\caption{SOS semantic rules of the c\CNA. Only rule $(Act)$ is
%changed. The others are the same as in Figure~\ref{fig:cnasos}, in the Appendix.}
%\label{fig:cnasos}
%\end{figure}

\begin{figure}[t]
\begin{center} 
\begin{prooftree} 
\AxiomC{$v \blackstretcheq v_j\quad j\in I$} %\mbox{($\ell$ {\em only} solid link in $s$)}
\RightLabel{\scriptsize(\textit{Sum})}
\UnaryInfC{$\sum_{i\in I} \upsilon_i.P_i \xrightarrow{v} P_j$} 
\DisplayProof
\
\AxiomC{$P \xrightarrow{v} P'$}
 \AxiomC{$(A \defeq P)\in\Delta$}
\RightLabel{\scriptsize(\textit{Ide})}
\BinaryInfC{$A \xrightarrow{v} P'$} 
%\AxiomC{$P \xrightarrow{v} P'$} 
%\RightLabel{\scriptsize(\textit{Lsum})}
%\UnaryInfC{$P+Q \xrightarrow{v} P'$} 
%\DisplayProof
%\
%\AxiomC{$Q \xrightarrow{s} Q'$} 
%\RightLabel{\scriptsize(Rsum)}
%\UnaryInfC{$P+Q \xrightarrow{s} Q'$} 
\end{prooftree} 
\end{center}

\begin{center} 
\begin{prooftree} 
\AxiomC{$P \xrightarrow{v} P'$} 
\RightLabel{\scriptsize(\textit{Res})}
\UnaryInfC{$\restrict{a}P \xrightarrow{\restrict{a}v} \restrict{a}P'$} 
\DisplayProof
%\,
%\AxiomC{$P \xrightarrow{v} P'$} 
%\RightLabel{\scriptsize(\textit{Rel})}
%\UnaryInfC{$P[\phi] \xrightarrow{v[\phi]} P'[\phi]$} 
%\DisplayProof
\AxiomC{$P \xrightarrow{v} P'$} 
\RightLabel{\scriptsize(\textit{Lpar})}
\UnaryInfC{$P|Q \xrightarrow{v} P'|Q$} 
\DisplayProof
%\,
%\AxiomC{$Q \xrightarrow{s} Q'$} 
%\RightLabel{\scriptsize(Rpar)}
%\UnaryInfC{$P|Q \xrightarrow{s} P|Q'$} 
%\end{prooftree} 
%\end{center}
%\begin{center} 
%\begin{prooftree} 
\AxiomC{$P \xrightarrow{v'} P'$} 
\AxiomC{$Q \xrightarrow{v} Q'$} 
\RightLabel{\scriptsize(\textit{Com})}
\BinaryInfC{$P|Q \xrightarrow{\merges{v}{v'}} P'|Q'$} 
%\DisplayProof
\end{prooftree} 
\end{center}
\caption{SOS semantics of the c\CNA\  (rules (\textit{Rel}) and (\textit{Rpar}) omitted).}
\label{fig:cnasos}
\end{figure}

\subsection{Notation for link chains}

Hereafter we make use of some new notations for link chains that will facilitate  
the presentation of our translation.
%First, we define the juxtaposition of link or link chains as
\begin{definition}[Replication]
Let $\upsilon$ be a link chain. Its $n$ times replication $\upsilon^n$ is defined recursively by letting
$\upsilon^0 = \epsilon$ (i.e. the empty chain) and $\upsilon^n = \upsilon^{n-1}\upsilon$,
%\[
%\begin{array}{c@{\qquad}c}
%%\ell ^1 = \ell & \ell^n = \ell^{n-1}\ell\\
%\upsilon^1 = \upsilon& \upsilon^n = \upsilon^{n-1}\upsilon
%\end{array}
%\]
with the hypothesis that all the links in the resulting link chains match.
%, and that $\upsilon^0 = \epsilon$ is the empty chain.
\end{definition}

For example,  the expression $(\startchain{a}\chainedlink{b}{\noact}\chainend{\noact})^3$  denotes the chain $\startchain{a}\chainedlink{b}{\noact}\chainedlink{\noact}{a}\chainedlink{b}{\noact}\chainedlink{\noact}{a}\chainedlink{b}{\noact}\chainend{\noact}$.

 \noindent
We introduce the \emph{half link} that will be used in conjunction with the \emph{open block of chain} to form regular link chains.

\begin{definition}[Half links]
Let $a$ be a channel name, we define the \emph{half left link}:  $\link{a}{}$,   and the  \emph{half right link}: $\link{}{a}$.
\end{definition}

\begin{definition}[Open block]
Let $R$ be a set of names. We 
define an \emph{open block} as $\blockchain{a_i}{a_o}{a \in R}$\ , where $a_i$ and $a_o$ are annotated version of the name $a$, as
\[
\begin{array}{l@{\quad}l@{\quad}l}
\mbox{set}& \mbox{block of chain}& \mbox{result}\\
R= \emptyset & \blockchain{a_i}{a_o}{a \in R}   &\epsilon\\
R = \{ b\}    &\blockchain{a_i}{a_o}{a \in R}  & {}_{b_i}^{\noact}\chainedlink{\noact}{b_o}\\
R = \{b\} \cup R' & \blockchain{a_i}{a_o}{a \in R} & {}_{b_i}^{\noact}\chainedlink{\noact}{b_o}\link{}{}\blockchain{a_i}{a_o}{a \in R'}
\end{array}
\]
\end{definition}
%Please note that, channel names of juxtaposed open blocks of chain are not required to match.

%\noindent
We then combine half links and  open blocks to form regular link chains.
%
%  $\halfl{a}\blockchain{c_i}{c_o}{c \in R}\halfr{b}$ to form a regular link chain; or we can put together half links and open blocks of chain:  $\halfl{a}\blockchain{c_i}{c_o}{c \in R}\blockchain{c_i}{c_o}{c \in R'}\dots \blockchain{c_i}{c_o}{c \in R^{''}}\halfr{b}$ to still form a regular  link chain.
% Again,  all the channel names appearing in the half links or in the open blocks of chain are not required to match.
 For example, for $R = \{a,b\}$ the expression $ \blockchain{c_i}{c_o}{c \in R} $\;
denotes the block of chains ${}_{a_i}^{\noact}\chainedlink{\noact}{a_o} \backslash{}_{b_i}^{\noact}\chainedlink{\noact}{b_o}$; and the expression $\link{r_1}{} \blockchain{c_i}{c_o}{c \in R}\;\link{}{r_2} $ denotes the chain $ \startchain{r_1}\chainedlink{a_i}{\noact}\chainedlink{\noact}{a_o}\chainedlink{b_i}{\noact}\chainedlink{\noact}{b_o}\chainend{r_2}$.
